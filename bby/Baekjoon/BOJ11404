import java.io.*;
import java.util.*;
 
public class Main {

    // 갈 수 없는 거리 설정
    static final int INF = 1000000;
 
    public static void main(String[] args) throws NumberFormatException, IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st;
 
        int N = Integer.parseInt(br.readLine());
        int M = Integer.parseInt(br.readLine());
        int[][] arr = new int[N + 1][N + 1];
 
        // 초기값 설정 : 출발 도시 = 도착 도시인 경우는 리턴 x
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                arr[i][j] = INF;
 
                if (i == j) {
                    arr[i][j] = 0;
                }
            }
        }
 
        // 도착 도시로의 시간 비용을 탐색
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            
            // 출발 도시와 도착 도시가 같지만 시간이 다른 입력값이 들어올 수 있음.
            // 예를 들어 "1 4 1"과 "1 4 2"가 입력으로 들어왔으면,
            // "1 4 1"을 택해야 함.
            // 최단 경로를 구하기 = c 가 작은 값이여야함.
            arr[a][b] = Math.min(arr[a][b], c); 
        }
 
        // 플로이드 워셜 알고리즘
        // 플로이드는 다익스트라와 달리 모든 정점에서의 최단경로 이기 때문에,
        // 일반적인 다익스트라의 N^2 시간복잡도 계산에서 N 의 정점 개수 만큼 반복을 해야함.
        // 그래서 N^3 이 되고 for 문을 3번 돌림.
        for (int k = 1; k <= N; k++) {
            for (int i = 1; i <= N; i++) {
                for (int j = 1; j <= N; j++) {
                
                    // 최단경로 초기화
                    // 다익스트라 dist 구할때 처럼, 최단경로와 비교하여 i > j 로 가는게 더 적으면
                    // 그것을 최단 경로로 갱신함
                    if (arr[i][j] > arr[i][k] + arr[k][j]) {
                        arr[i][j] = arr[i][k] + arr[k][j];
                    }
                }
            }
        }
 
        StringBuilder sb = new StringBuilder();
        
        // i = j 랑 마찬가지로, 시작과 도착의 도시가 달라도 갈 수 없으면 0 으로 설정하기.
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                if (arr[i][j] == INF) {
                    arr[i][j] = 0;
                }
 
                sb.append(arr[i][j] + " ");
            }
            sb.append("\n");
        }
 
        bw.write(sb.toString());
        bw.flush();
        bw.close();
        br.close();
    }
 
}
